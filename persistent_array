
================================================================================
SECTION A — Persistent Segment Tree (mảng phiên bản, range sum)
================================================================================
API (pool-based, 0-index):
- build(arr): trả về root phiên bản gốc từ mảng values[0..n-1]
- update(prev_root, pos, new_val): trả về root phiên bản mới sau khi set values[pos]=new_val
- query(root, ql, qr): trả về tổng đoạn [ql, qr] tại phiên bản root
Ghi chú:
- Có thể thay merge (sum) thành min/max/xor... và đổi neutral tương ứng.
- Nếu cần range update, dùng kỹ thuật khác (lazy persistent phức tạp hơn) hoặc Fenwick không phù hợp cho persistence chuẩn.

struct PSTSum {
    struct Node { int L, R; long long sum; };
    static constexpr int MAX_POOL = 1 << 20; // điều chỉnh theo nhu cầu
    int n;
    int pool_ptr;
    Node pool[MAX_POOL];

    PSTSum(): n(0), pool_ptr(1) {
        pool[0].L = pool[0].R = 0;
        pool[0].sum = 0;
    }

    int new_node(int from = 0) {
        if (pool_ptr >= MAX_POOL) throw runtime_error("PSTSum pool exhausted");
        pool[pool_ptr] = pool[from];
        return pool_ptr++;
    }

    int build_rec(const vector<long long>& a, int l, int r) {
        int u = new_node(0);
        if (l == r) { pool[u].sum = a[l]; return u; }
        int m = (l + r) >> 1;
        pool[u].L = build_rec(a, l, m);
        pool[u].R = build_rec(a, m + 1, r);
        pool[u].sum = pool[ pool[u].L ].sum + pool[ pool[u].R ].sum;
        return u;
    }

    int build(const vector<long long>& a) {
        n = (int)a.size();
        return n ? build_rec(a, 0, n - 1) : 0;
    }

    int update_rec(int prev, int l, int r, int pos, long long val) {
        int u = new_node(prev);
        if (l == r) { pool[u].sum = val; return u; }
        int m = (l + r) >> 1;
        if (pos <= m) pool[u].L = update_rec(pool[prev].L, l, m, pos, val);
        else          pool[u].R = update_rec(pool[prev].R, m + 1, r, pos, val);
        pool[u].sum = pool[ pool[u].L ].sum + pool[ pool[u].R ].sum;
        return u;
    }

    int update(int prev_root, int pos, long long val) {
        if (n == 0) return 0; // no-op
        return update_rec(prev_root, 0, n - 1, pos, val);
    }

    long long query_rec(int u, int l, int r, int ql, int qr) const {
        if (!u || qr < l || r < ql) return 0LL; // neutral cho sum
        if (ql <= l && r <= qr) return pool[u].sum;
        int m = (l + r) >> 1;
        return query_rec(pool[u].L, l, m, ql, qr) + query_rec(pool[u].R, m + 1, r, ql, qr);
    }

    long long query(int root, int ql, int qr) const {
        if (n == 0 || ql > qr) return 0LL;
        ql = max(ql, 0); qr = min(qr, n - 1);
        return query_rec(root, 0, n - 1, ql, qr);
    }
};

/*
Sử dụng nhanh:
    PSTSum pst;
    int r0 = pst.build(a);              // phiên bản 0
    int r1 = pst.update(r0, i, x);      // phiên bản 1
    long long s = pst.query(r1, L, R);  // query trên phiên bản 1
*/

/*
================================================================================
SECTION B — Persistent Binary Trie (số nguyên, 0-index, MSB-first)
================================================================================
API:
- add(prev_root, x, +1/-1): thêm/xoá một số x, trả về root mới
- countLess(root, x): đếm số phần tử < x
- maxXor(root, x): tìm giá trị y trong trie tối đa hoá (x xor y)
Ghi chú:
- Thay MAX_BITS tuỳ miền giá trị (mặc định 31 cho int không âm < 2^31).
*/

struct PBinaryTrie {
    struct Node { int ch[2]; int cnt; Node(){ ch[0] = ch[1] = 0; cnt = 0; } };
    static constexpr int MAX_POOL = 1 << 21; // điều chỉnh theo nhu cầu
    int MAX_BITS;
    int node_ptr;
    Node pool[MAX_POOL];

    PBinaryTrie(int MAX_BITS = 31): MAX_BITS(MAX_BITS), node_ptr(1) {
        pool[0] = Node();
    }

    int clone(int from) {
        if (node_ptr >= MAX_POOL) throw runtime_error("PBinaryTrie pool exhausted");
        pool[node_ptr] = pool[from];
        return node_ptr++;
    }

    int add(int prev, int x, int delta) {
        int u = clone(prev); pool[u].cnt += delta; int cur = u;
        for (int b = MAX_BITS; b >= 0; --b) {
            int bit = (x >> b) & 1;
            int nxt = pool[cur].ch[bit];
            int v = clone(nxt);
            pool[cur].ch[bit] = v; cur = v; pool[cur].cnt += delta;
        }
        return u;
    }

    int countLess(int root, int x) const {
        long long res = 0; int cur = root;
        for (int b = MAX_BITS; b >= 0 && cur; --b) {
            int bit = (x >> b) & 1;
            if (bit) { res += (long long)pool[ pool[cur].ch[0] ].cnt; cur = pool[cur].ch[1]; }
            else cur = pool[cur].ch[0];
        }
        return (int)res;
    }

    int maxXor(int root, int x) const {
        int cur = root, ans = 0; if (!cur) return 0;
        for (int b = MAX_BITS; b >= 0; --b) {
            int bit = (x >> b) & 1, want = bit ^ 1;
            int to = pool[cur].ch[want];
            if (to && pool[to].cnt > 0) { ans |= (1 << b); cur = to; }
            else cur = pool[cur].ch[bit];
            if (!cur) break;
        }
        return ans; // trả về (x xor best)
    }
};

/*
Sử dụng nhanh:
    PBinaryTrie bt(31);
    int r0 = 0;                // r0 là 0 (trie rỗng)
    int r1 = bt.add(r0, 5, +1);
    int r2 = bt.add(r1, 8, +1);
    int c  = bt.countLess(r2, 7);     // đếm < 7
    int xo = bt.maxXor(r2, 10);       // giá trị (10 xor best)
*/
================================================================================
GỢI Ý/RECIPE PHỔ BIẾN
================================================================================
- Versioned array: dùng PSTSum; mỗi update tạo root mới, truy vấn theo phiên bản.
- Distinct count trên [L,R]: lưu tại vị trí cuối cùng của mỗi giá trị, update khi gặp lại.
- K-th nhỏ nhất trên đoạn: cần PST theo tần suất (value-compressed) + tìm nhị phân trên cây.
- Binary trie: đếm < X theo phiên bản, truy vấn max xor theo phiên bản.
